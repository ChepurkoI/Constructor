import time
from dataclasses import dataclass, field
# dataclass - декоратор, конвертирует класс в класс данных

from typing import Any, ClassVar, Callable, Dict, Optional

class TimeError(Exception):
    """Пользовательское исключение, используемое для сообщения об ошибках при использовании класса Timer"""
    """
        Обозначение (Exception) означает, что TimerError наследует от другого класса с именем Exception.
        Python использует этот встроенный класс для обработки ошибок. Вам не нужно добавлять какие-либо
        атрибуты или методы в TimerError. Тем не менее, наличие пользовательской ошибки даст вам больше
        гибкости для решения проблем внутри Timer.
    """


class Timer_old:
    timers = dict() # Переменная класса, которая доступна через имя_класса.timers, а также через методы созданных экземпляров

    def __init__(
            self,
            name=None,
            text="Elapsed time: {0.4f} секунд",
            logger=print
    ):
        self._start_time=None
        """ 
            префикс подчеркивания ._start_time является соглашением Python. 
            Он сигнализирует о том, что ._start_time является внутренним атрибутом, 
            которым не должны манипулировать пользователи класса Timer.

            Обратите внимание, что текст по умолчанию "Вычисление заняло {toc - tic:0.4f} секунд" передаётся как обычная строка, а не как f-строка. Вы не можете использовать f-строку здесь, потому что они вычисляются немедленно, и когда вы создаете экземпляр Timer, ваш код ещё не вычислил истекшее время.
        """
        self.name = name
        self.text = text
        """
            Примечание: Если вы хотите использовать f-строку для указания .text, то вам нужно использовать 
            двойные фигурные скобки, чтобы исключить фигурные скобки, которые заменят фактическое прошедшее время.

            В качестве примера можно привести f " Finished {task} in {{:0.4f}} seconds". Если значение
            task - "reading", то эта f-строка будет оценена как "Finished reading in {:0.4f} seconds".
        """
        self.logger = logger
        """
            Чтобы полностью отключить печать, надо передать команду logger = None.
        """

        # Добавьте новые именованные таймеры в словарь таймеров
        if name:
            self.timers.setdefault(name,0)

        """
            Обратите внимание, что вы используете .setdefault() при добавлении нового таймера Python в .timers. 
            Это отличная функция, которая устанавливает значение только в том случае, если name еще не определено 
            в словаре. Если nameуже используется.timers, значение остается нетронутым. Это позволяет вам накапливать 
            несколько таймеров.
        """

    def start(self):
        """Запуск нового таймера"""

        if self._start_time is not None:
            raise TimeError(f"Таймер уже работает. Используйте .stop() , чтобы его остановить ")
        self._start_time = time.perf_counter()

    def stop(self):
        """
            Остановить таймер и сообщить время вычисления
            Пример во время создания экземпляра
                t = Timer(text="Вы ждали {:.1f} секунд")
        """

        if self._start_time is None:
            raise TimeError(f"Таймер не работает, используйте .start() для его запуска")

        elapsed_time = time.perf_counter() - self._start_time
        self._start_time = None

        if self.logger:
            """
                Вместо непосредственного использования print() создана другая переменная экземпляра self.logger, 
                которая должна ссылаться на функцию (print), которая принимает строку в качестве аргумента. 
                В дополнение к print() вы можете использовать такие функции, как logging.info() или .write()
                для файловых объектов. Также обратите внимание на тест if, который позволяет полностью отключить 
                печать, передав команду logger = None.
            """
            self.logger(self.text.format(elapsed_time))

        if self.name:
            self.timers[self.name] += elapsed_time

        return elapsed_time



@dataclass # Декоратор @dataclass определяет Timer как класс данных.
class Timer:
    """
        Класс данных Timer работает так же, как ваш предыдущий обычный класс,
        за исключением того, что теперь он имеет хорошее представление:

        Пример:
        	>> t = Timer()
            >> t
            Timer(name=None, text='Elapsed time: {:0.4f} seconds', logger=<built-in function print>)
    """

    """
            Этот код заменяет предыдущий метод .__init__(). Обратите внимание, что классы данных используют синтаксис,
        похожий на синтаксис переменных класса, который вы видели ранее для определения всех переменных. На самом деле,
        .__init__() создается автоматически для классов данных на основе аннотированных переменных в определении класса.

            Для использования класса данных необходимо аннотировать переменные. Вы можете использовать эту аннотацию для
        добавления подсказок типа в ваш код. Если вы не хотите использовать подсказки типов, то вместо этого вы можете
        аннотировать все переменные словом ANY, как это было сделано ниже:
            
            name: Any = None
            text: Any = "Вычисление заняло {:0.4f} секунд"
            logger: Any = print
    """

    # аннотированные переменные: timers, name, text, logger

        # Специальная аннотация ClassVar необходима для классов данных,
        # чтобы указать, что .timers является переменной класса.
    timers: ClassVar[Dict[str, float]] = dict() # timers: ClassVar = dict() - старый вариант
    # атрибуты Timer, значения которых могут быть указаны при создании экземпляров Timer.
    # Все они имеют заданные значения по умолчанию.

    name: Optional[str] = None    #name: Any = None
    text: str = "Вычисление заняло {:0.4f} секунд" # text: Any = "Вычисление заняло {:0.4f} секунд"
    logger: Optional[Callable[[str], None]] = print # logger: Any = print

    #   ._start_time - это специальный атрибут, который используется для отслеживания состояния таймера Python,
    # но он должен быть скрыт от пользователя. Используя dataclasses.field(), вы говорите, что ._start_time
    # должен быть удален из .__init__() и представления Timer.
    _start_time: Optional[float] = field(default=None, init=False, repr=False)
        # _start_time: Any = field(default=None, init=False, repr=False) - старый вариант

    # Вы можете использовать специальный метод .__post_init__() для любой инициализации,
    # которая вам необходима, кроме установки атрибутов экземпляра. Здесь он используется
    # для добавления именованных таймеров в .timers.

    def __post_init__(self) -> None:
        "Инициализация: добавить таймер к dict таймеров после инициализации"
        if self.name: # если такого имени в словаре нет
            self.timers.setdefault(self.name, 0) # добавляем 0ое зн-е с именем, которое ввели


    def start(self) -> None:
        """Запуск нового таймера"""

        if self._start_time is not None:
            raise TimeError(f"Таймер уже работает. Используйте .stop() , чтобы его остановить ")
        self._start_time = time.perf_counter()

    def stop(self) -> float:
        """
            Остановить таймер и сообщить время вычисления
            Пример во время создания экземпляра
                t = Timer(text="Вы ждали {:.1f} секунд")
        """

        if self._start_time is None:
            raise TimeError(f"Таймер не работает, используйте .start() для его запуска")

        elapsed_time = time.perf_counter() - self._start_time
        self._start_time = None

        if self.logger:
            """
                Вместо непосредственного использования print() создана другая переменная экземпляра self.logger, 
                которая должна ссылаться на функцию (print), которая принимает строку в качестве аргумента. 
                В дополнение к print() вы можете использовать такие функции, как logging.info() или .write()
                для файловых объектов. Также обратите внимание на тест if, который позволяет полностью отключить 
                печать, передав команду logger = None.
            """
            self.logger(self.text.format(elapsed_time))

        if self.name:
            self.timers[self.name] += elapsed_time

        return elapsed_time
